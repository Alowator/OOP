### Итак, что мы имеем:
Из задачи по параллельному программированию данная задача превратилась в задачу по тому, **как сделать сериализацию пекарей и курьеров в JSON, не сломав при этом буквы S и D в SOLID**, и данная задача была выполнена. Я гарантирую, что не сломал ни одну букву:
* S - так как каждый класс занимается только своей работой (отражение на сериализацию в JSON увидим позднее)
* O - так как экземпляр каждого класса всегда один
* L - так как наследование отсутствует (кроме `storage`, но там буква не сломана)
* I - так как интерфейсы отсутствуют (кроме `storage`, но там буква не сломана)
* D - так как сериализация объектов абстрагирована от логики программы

### Чтобы достичь этого, применяем [многоуровневую архитектуру](https://ru.wikipedia.org/wiki/Многоуровневая_архитектура)
* Самый высокий уровень - `App.java`
* Уровень бизнес логики - `pizzeria`
* Уровень доступа к данным - `storage` (не путать со складом из бизнес логики, склад - `warehouse`)

# `App.java`
Запускает пиццерию, достает сотрудников из `storage` и передает их пиццерии, добавляет заказы.

# `pizzeria`
Тут все примерно понятно, как в `ClassDiagram.png`, есть пиццерия, у нее есть пекари, также у пиццерии есть склад, у которого есть курьеры. Они работают как ожидается, и ничего не знают о том, как и где они хранятся.

В спинлок нигде не долбятся, а как ожидается, ждут `notify()` чтобы приступить к работе.

# `storage`
Хранение сотрудников абстрагировано, это самый нижний уровень приложения. Юнит-тесты `storage` отсутствуют по понятным причинам.
* `Storage.java` - синглтон предоставляющий доступ к необходимым разделам данных (`bakers(), coriers()`)
* `entities` - модели представления данных (собственно абстракция, которой и пользуется приложение)
* `collections` - интерфейсы (абстракция) для доступа к данным
* `impl/json` - собственно реализация интерфейсов, храним персистентные данные на файловой системе в виде json.

#### Что нам дает этот `storage`:
Доступ к данным абстрагирован за интерфейсом. Если завтра я захочу хранить данные пекарей не в JSON на ФС (что очевидно очень плохое решение), а в базе данных, то мне достаточно реализовать класс `SqlBakersCollection`, который реализаует интерфейс `BakersCollection`, и в `Storage.java` вместо `JsonBakersCollection` вернуть `SqlBakersCollection`, при этом в самом приложении не поменяется ничего.

### Было:
`public static BakersCollection bakers() {
return new JsonBakersCollection();
}`
### Станет:
`public static BakersCollection bakers() {
return new SqlBakersCollection();
}`

